# 代理模式
为其他对象提供一种代理以控制对这个对象的访问。

`注意：`Proxy模式和Decorator模式有些类似。确实，这两者看起来很像，但区别在于：Decorator模式让调用者自己创建核心类，
然后组合各种新功能到核心类上；而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能，Proxy模式让调用者认为获取到的是核心类接口，
但实际上是代理类。

# 最佳实践
1. 远程代理：远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。
2. 虚代理：虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。
JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。
3. 保护代理：保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。
4. Spring AOP：Spring AOP的实现其实就是使用java的动态代理和CGLib代理。
5. 智能引用：智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。